<Project>

  <Target Name="AddInternalsVisibleTo" BeforeTargets="BeforeCompile" Label="Adds InternalsVisibleTo Attribute and PublicKey (if supplied)">
    <ItemGroup Condition="'@(InternalsVisibleTo->Count())' &gt; 0 ">
      <AssemblyAttribute Include="System.Runtime.CompilerServices.InternalsVisibleTo">
        <_Parameter1>%(InternalsVisibleTo.Identity)</_Parameter1>
        <_Parameter1 Condition=" '$(SignAssembly)' == 'true' And '$(PublicKey)' != '' ">%(InternalsVisibleTo.Identity), PublicKey=$(PublicKey)</_Parameter1>
      </AssemblyAttribute>
    </ItemGroup>
  </Target>

  <Target Name="PrintTargetFrameworks" Label="Prints the value for the $(TargetFrameworks) property or 'none' if no frameworks apply. Pass TestProjectsOnly=true to get results only if this is a test project.">
    <PropertyGroup>
      <DoOutputTargetFrameworks Condition=" '$(TestProjectsOnly)' != 'true' Or ('$(TestProjectsOnly)' == 'true' And '$(IsTestProject)' == 'true')">true</DoOutputTargetFrameworks>
      <OutputTargetFrameworks Condition=" '$(DoOutputTargetFrameworks)' == 'true' ">$(TargetFramework)</OutputTargetFrameworks>
      <!-- Fallback to TargetFrameworks field if TargetFramework is empty -->
      <OutputTargetFrameworks Condition=" '$(DoOutputTargetFrameworks)' == 'true' And '$(OutputTargetFrameworks)' == '' ">$(TargetFrameworks)</OutputTargetFrameworks>
      <OutputTargetFrameworks Condition=" '$(OutputTargetFrameworks)' == '' ">none</OutputTargetFrameworks>
    </PropertyGroup>
    <Message Text="$(OutputTargetFrameworks)" Importance="high"/>
  </Target>

  <ItemGroup>
    <PackageReference Include="NuGet.Versioning" PrivateAssets="All" />
  </ItemGroup>

  <PropertyGroup>
    <NuGetPackageRoot Condition=" '$(NUGET_PACKAGES)' != '' ">$(NUGET_PACKAGES)</NuGetPackageRoot>
  </PropertyGroup>

  <Target Name="GenerateMatrix">
    <PropertyGroup>
      <MatrixOutputDir>$(RepositoryRoot)_artifacts\TestMatrix\$(MatrixId)</MatrixOutputDir>
    </PropertyGroup>

    <Message Text="NuGetPackageRoot = '$(NuGetPackageRoot)'" Importance="High" />
    <Message Text="NUGET_PACKAGES (env) = '$(NUGET_PACKAGES)'" Importance="High" />
    <Message Text="Resolved NuGet.Versioning DLL: $([System.IO.Path]::Combine('$(NuGetPackageRoot)', 'nuget.versioning', '$(NuGetVersioningPackageVersion)', 'lib', 'netstandard2.0', 'NuGet.Versioning.dll'))" Importance="High" />

    <GenerateCartesianMatrix Options="@(MatrixOption)"
                             Excludes="@(ExcludeMatrixCombination)"
                             PackageRefs="@(MatrixPackageReference)"
                             OutputDir="$(MatrixOutputDir)"
                             IDPrefix="$(MatrixId)" />

    <Message Importance="high" Text="Generated test matrix at $(MatrixOutputDir)" />

  </Target>

  <UsingTask TaskName="GenerateCartesianMatrix" TaskFactory="RoslynCodeTaskFactory" AssemblyFile="$(MSBuildToolsPath)\Microsoft.Build.Tasks.Core.dll">
    <ParameterGroup>
      <IDPrefix ParameterType="System.String" Required="true" />
      <Options ParameterType="Microsoft.Build.Framework.ITaskItem[]" Required="true" />
      <Excludes ParameterType="Microsoft.Build.Framework.ITaskItem[]" Required="false" />
      <PackageRefs ParameterType="Microsoft.Build.Framework.ITaskItem[]" Required="false" />
      <OutputDir ParameterType="System.String" Required="true" />
    </ParameterGroup>
    <Task>
      <Reference Include="$([System.IO.Path]::Combine('$(NuGetPackageRoot)', 'nuget.versioning', '$(NuGetVersioningPackageVersion)', 'lib', 'netstandard2.0', 'NuGet.Versioning.dll'))" />
      <Using Namespace="NuGet.Versioning" />
      <Using Namespace="System" />
      <Using Namespace="System.IO" />
      <Using Namespace="System.Collections.Generic" />
      <Using Namespace="System.Linq" />
      <Using Namespace="System.Security.Cryptography" />
      <Using Namespace="System.Text" />
      <Code Type="Fragment" Language="cs">
        <![CDATA[
          // Exclude Metadata
          var excludeMetadataKeys = new HashSet<string>(StringComparer.OrdinalIgnoreCase)
          {
              "Filename", "FullPath", "RootDir", "Directory", "Identity", "DefiningProjectFullPath", "DefiningProjectDirectory", "DefiningProjectName", "DefiningProjectExtension"
          };
        
          // Parse matrix options
          var allOptions = new Dictionary<string, string[]>(StringComparer.OrdinalIgnoreCase);
          foreach (var opt in Options)
              allOptions[opt.ItemSpec] = (opt.GetMetadata("Values") ?? "")
                  .Split(new[]{';'}, StringSplitOptions.None);

          var validKeys = new HashSet<string>(allOptions.Keys, StringComparer.OrdinalIgnoreCase);

          // Parse excludes
          var excludes = new List<Dictionary<string,string>>();
          foreach (var ex in Excludes ?? Array.Empty<ITaskItem>()) {
              var dict = new Dictionary<string,string>(StringComparer.OrdinalIgnoreCase);
              foreach (string name in ex.MetadataNames) {
                  if (!validKeys.Contains(name)) continue;
                  var value = ex.GetMetadata(name);
                  if (!string.IsNullOrEmpty(value)) dict[name] = value;
              }
              if (dict.Count > 0) excludes.Add(dict);
          }

          // Parse MatrixPackageReference items
          var packageDefs = new List<(string Option,string PackageId,string[] WhenValues,string[] Versions,Dictionary<string,string> Metadata)>();
          foreach (var pkg in PackageRefs ?? Array.Empty<ITaskItem>()) {
              var option = pkg.ItemSpec;
              var id = pkg.GetMetadata("PackageId");
              var whenValues = (pkg.GetMetadata("WhenValue") ?? "").Split(new[]{';'}, StringSplitOptions.RemoveEmptyEntries);
              var versions = (pkg.GetMetadata("Versions") ?? "").Split(new[]{';'}, StringSplitOptions.RemoveEmptyEntries);
              if (string.IsNullOrEmpty(option) || string.IsNullOrEmpty(id)) continue;

              var meta = new Dictionary<string,string>(StringComparer.OrdinalIgnoreCase);
              foreach (string m in pkg.MetadataNames) {
                  var v = pkg.GetMetadata(m);
                  if (!string.IsNullOrEmpty(v) && m != "PackageId" && m != "WhenValue" && m != "Versions")
                      meta[m] = v;
              }
              packageDefs.Add((option,id,whenValues,versions,meta));
          }

          // Cartesian product of matrix options
          var keys = allOptions.Keys.ToList();
          var combos = new List<Dictionary<string,string>>();
          void Recurse(int i, Dictionary<string,string> cur) {
              if (i == keys.Count) {
                  foreach (var ex in excludes) {
                      bool match = ex.All(kv => cur.TryGetValue(kv.Key, out var val) &&
                          string.Equals(val, kv.Value, StringComparison.OrdinalIgnoreCase));
                      if (match) return; // exclude combo
                  }
                  combos.Add(new Dictionary<string,string>(cur, StringComparer.OrdinalIgnoreCase));
                  return;
              }
              var key = keys[i];
              foreach (var val in allOptions[key]) {
                  cur[key] = val;
                  Recurse(i + 1, cur);
              }
          }
          Recurse(0, new Dictionary<string,string>());

          string MakeSafeId(string s) {
              var sb = new StringBuilder(s.Length);
              foreach (var c in s) sb.Append(char.IsLetterOrDigit(c) ? c : '_');
              return sb.ToString();
          }
          
          string ResolveNuGetVersion(string v1, string v2)
          {
              if (string.IsNullOrEmpty(v1)) return v2;
              if (string.IsNullOrEmpty(v2)) return v1;

              if (!NuGetVersion.TryParse(v1, out var n1))
                  n1 = new NuGetVersion(v1);
              if (!NuGetVersion.TryParse(v2, out var n2))
                  n2 = new NuGetVersion(v2);

              return (n1.CompareTo(n2) >= 0 ? n1 : n2).ToNormalizedString();
          }


          Directory.CreateDirectory(OutputDir);

          foreach (var combo in combos) {

              // Start with one variant
              var variants = new List<(Dictionary<string,string> Combo, Dictionary<string,(string Version,Dictionary<string,string> Metadata)> Packages)>
              {
                  (new Dictionary<string,string>(combo, StringComparer.OrdinalIgnoreCase),
                   new Dictionary<string,(string,Dictionary<string,string>)>(StringComparer.OrdinalIgnoreCase))
              };

              // Expand variants based on package references
              foreach (var pkg in packageDefs)
              {
                  if (!combo.TryGetValue(pkg.Option, out var optVal))
                      continue;

                  if (!pkg.WhenValues.Any(wv => string.Equals(wv, optVal, StringComparison.OrdinalIgnoreCase)))
                      continue;

                  bool hasExclude = pkg.Versions.Any(v => string.Equals(v, "Exclude", StringComparison.OrdinalIgnoreCase));
                  var realVersions = pkg.Versions
                      .Where(v => !string.Equals(v, "Exclude", StringComparison.OrdinalIgnoreCase))
                      .ToArray();

                  var newVariants = new List<(Dictionary<string,string>, Dictionary<string,(string,Dictionary<string,string>)>)>();

                  foreach (var variant in variants)
                  {
                      // For each real version, add a variant with the package
                      foreach (var ver in realVersions)
                      {
                          var copyCombo = new Dictionary<string,string>(variant.Combo, StringComparer.OrdinalIgnoreCase);
                          var copyPkgs = new Dictionary<string,(string Version,Dictionary<string,string> Metadata)>(variant.Packages, StringComparer.OrdinalIgnoreCase);
                          if (copyPkgs.TryGetValue(pkg.PackageId, out var existing))
                          {
                              // Combine multiple versions for same PackageId
                              var mergedVersion = ResolveNuGetVersion(existing.Version, ver);
                              copyPkgs[pkg.PackageId] = (mergedVersion, pkg.Metadata);
                          }
                          else
                          {
                              copyPkgs[pkg.PackageId] = (ver, pkg.Metadata);
                          }
                          newVariants.Add((copyCombo, copyPkgs));
                      }

                      // Add an "Exclude" variant with no package if requested
                      if (hasExclude)
                      {
                          var copyCombo = new Dictionary<string,string>(variant.Combo, StringComparer.OrdinalIgnoreCase);
                          var copyPkgs = new Dictionary<string,(string,Dictionary<string,string>)>(variant.Packages, StringComparer.OrdinalIgnoreCase);
                          newVariants.Add((copyCombo, copyPkgs));
                      }
                  }

                  variants = newVariants;
              }

              // Write each variant to file
              foreach (var variant in variants)
              {
                  var idRaw = string.Join(";", variant.Combo.OrderBy(k => k.Key).Select(kv => $"{kv.Key}={kv.Value}")) +
                              string.Join(";", variant.Packages.Select(p => $"{p.Key}={p.Value.Version}"));
                  var bytes = Encoding.UTF8.GetBytes(idRaw);
                  var hash = BitConverter.ToString(SHA1.Create().ComputeHash(bytes)).Replace("-", "").Substring(0, 8);
                  var id = $"{IDPrefix}_{hash}";
                  var file = Path.Combine(OutputDir, $"{id}.props");

                  using var writer = new StreamWriter(file);
                  writer.WriteLine("<Project>");
                  writer.WriteLine("  <PropertyGroup>");
                  foreach (var kv in variant.Combo.OrderBy(k => k.Key))
                      writer.WriteLine($"    <{kv.Key}>{System.Security.SecurityElement.Escape(kv.Value)}</{kv.Key}>");

                  // Write package version properties
                  foreach (var pkg in variant.Packages)
                      writer.WriteLine($"    <PackageReference_{MakeSafeId(pkg.Key)}_Version>{pkg.Value.Version}</PackageReference_{MakeSafeId(pkg.Key)}_Version>");

                  writer.WriteLine($"    <MatrixId>{id}</MatrixId>");
                  writer.WriteLine("  </PropertyGroup>");

                  // Write PackageReference item group if any
                  if (variant.Packages.Count > 0)
                  {
                      writer.WriteLine("  <ItemGroup>");
                      foreach (var pkg in variant.Packages)
                      {
                          var idEsc = System.Security.SecurityElement.Escape(pkg.Key);
                          var verEsc = System.Security.SecurityElement.Escape(pkg.Value.Version);
                          writer.Write($"    <PackageReference Include=\"{idEsc}\" Version=\"{verEsc}\"");
                          foreach (var kv in pkg.Value.Metadata)
                          {
                              if (!excludeMetadataKeys.Contains(kv.Key))
                                  writer.Write($" {kv.Key}=\"{System.Security.SecurityElement.Escape(kv.Value)}\"");
                          }
                          writer.WriteLine(" />");
                      }
                      writer.WriteLine("  </ItemGroup>");
                  }

                  writer.WriteLine("</Project>");
              }
          }
        ]]>
      </Code>
    </Task>
  </UsingTask>

  <!-- For now, excluding this on Azure DevOps is required for the scripts to properly insert the version numbers, even though we could use the default Nerbank.GitVersioning setup (in theory) because we are strictly following semver -->
  <ItemGroup Condition=" '$(SkipGitVersioning.ToLower())' != 'true' ">
    <PackageReference Include="Nerdbank.GitVersioning" PrivateAssets="All" />
  </ItemGroup>
  
</Project>
