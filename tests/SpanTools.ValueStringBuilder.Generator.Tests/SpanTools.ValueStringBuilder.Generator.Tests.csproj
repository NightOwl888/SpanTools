<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net8.0</TargetFramework>
    <Nullable>enable</Nullable>
    <RootNamespace Condition=" '$(ImportPropsFile)' == '' ">SpanTools.Generator.Tests</RootNamespace>
    <IsTestProject>true</IsTestProject>
  </PropertyGroup>

  <PropertyGroup Label="Test Matrix">
    <MatrixId>$(AssemblyName)</MatrixId>
  </PropertyGroup>

  <ItemGroup Label="Test Matrix">
    <MatrixOption Include="AllowUnsafeBlocks" Values="true;false" />
    <!--<MatrixOption Include="RootNamespace" Values="MyNamespace;Lucene.Net.Text" />
    <MatrixOption Include="ValueStringBuilder_Namespace" Values="MyNamespace;global::;Lucene.Net.Text;" />-->
    <MatrixOption Include="ValueStringBuilder_Namespace" Values="Lucene.Net.Text" />

    <!--<MatrixOption Include="ValueStringBuilder_IncludeAsMemoryMethods" Values="true;false" />
    <MatrixOption Include="ValueStringBuilder_IncludeMaxLengthTracking" Values="true;false" />-->
    <MatrixOption Include="ValueStringBuilder_IncludeCodepointSupport" Values="true;false" />
    <MatrixOption Include="ValueStringBuilder_UseJavaStyleFormatting" Values="true;false" />
  </ItemGroup>

  <ItemGroup Label="Test Matrix Packages">
    <MatrixPackageReference Include="ValueStringBuilder_UseJavaStyleFormatting">
      <WhenValue>true</WhenValue>
      <PackageId>J2N</PackageId>
      <Versions>2.2.0-alpha-0026</Versions>
    </MatrixPackageReference>
    <MatrixPackageReference Include="ValueStringBuilder_IncludeCodepointSupport">
      <WhenValue>true</WhenValue>
      <PackageId>J2N</PackageId>
      <Versions>2.1.0</Versions>
    </MatrixPackageReference>
  </ItemGroup>

  <!--<ItemGroup Label="Test Matrix Excludes">
    <ExcludeMatrixCombination Include="RootVsValueNamespaceConflict1" RootNamespace="MyNamespace" ValueStringBuilder_Namespace="MyNamespace" Reason="Cannot have both namespaces active." />
    <ExcludeMatrixCombination Include="RootVsValueNamespaceConflict2" RootNamespace="MyNamespace" ValueStringBuilder_Namespace="global::" Reason="Cannot have both namespaces active." />
    <ExcludeMatrixCombination Include="RootVsValueNamespaceConflict3" RootNamespace="MyNamespace" ValueStringBuilder_Namespace="Lucene.Net.Text" Reason="Cannot have both namespaces active." />
    
    <ExcludeMatrixCombination Include="RootVsValueNamespaceConflict4" RootNamespace="Lucene.Net.Text" ValueStringBuilder_Namespace="MyNamespace" Reason="Cannot have both namespaces active." />
    <ExcludeMatrixCombination Include="RootVsValueNamespaceConflict6" RootNamespace="Lucene.Net.Text" ValueStringBuilder_Namespace="global::" Reason="Cannot have both namespaces active." />
    <ExcludeMatrixCombination Include="RootVsValueNamespaceConflict6" RootNamespace="Lucene.Net.Text" ValueStringBuilder_Namespace="Lucene.Net.Text" Reason="Cannot have both namespaces active." />
  </ItemGroup>-->

  <ItemGroup>
    <ProjectReference Include="..\SpanTools.TestUtilities\SpanTools.TestUtilities.csproj" />
  </ItemGroup>

  <PropertyGroup>
    <!-- Detect if PackageOutputPath was passed explicitly on the command line -->
    <_IsPackageOutputPathOverridden>$([System.Text.RegularExpressions.Regex]::IsMatch('$(MSBuildCommandLineArgs)', '(?i)(?:^|[ ;])[-/]p:PackageOutputPath='))</_IsPackageOutputPathOverridden>
    <_ArtifactsDirectory>$([System.IO.Path]::GetFullPath('$(MSBuildThisFileDirectory)..\..\_artifacts'))</_ArtifactsDirectory>
    <_NuGetPackageOutputPath>$(_ArtifactsDirectory)\NuGetPackages\$(Configuration)</_NuGetPackageOutputPath>
    <_NuGetPackageOutputPath Condition=" '$(_IsPackageOutputPathOverridden.ToLower())' == 'true' ">$(PackageOutputPath)</_NuGetPackageOutputPath>
    <_PackageVersionPropsFilePath>$(_NuGetPackageOutputPath)\SpanTools.ValueStringBuilder.Generator.Version.props</_PackageVersionPropsFilePath>
    <!-- We install the analyzer package in a local directory so we don't pollute the
          .nuget cache on the dev machine with temporary builds -->
    <RestorePackagesPath>obj/LocalNuGetPackages</RestorePackagesPath>
    <_RestorePackagesPath>$(RestorePackagesPath)/spantools.valuestringbuilder.generator</_RestorePackagesPath>
  </PropertyGroup>

  <PropertyGroup>
    <RestoreSources Condition="Exists('$(_NuGetPackageOutputPath)')">$(RestoreSources);$(_NuGetPackageOutputPath)</RestoreSources>
    <RestoreSources>$(RestoreSources);https://api.nuget.org/v3/index.json</RestoreSources>
  </PropertyGroup>

  <PropertyGroup>
    <!-- Visual Studio blocks MSBuild from being able to check whether files are up-to-date.
          So, we disable that here to gain access to that info. -->
    <DisableFastUpToDateCheck>true</DisableFastUpToDateCheck>
  </PropertyGroup>

  <Import Project="$(_PackageVersionPropsFilePath)" Condition="Exists('$(_PackageVersionPropsFilePath)')" />

  <ItemGroup Condition="Exists('$(_PackageVersionPropsFilePath)')">
    <PackageReference Include="SpanTools.ValueStringBuilder.Generator" VersionOverride="$(_SpanToolsPackageVersion)" />
  </ItemGroup>

  <ItemGroup Condition="!Exists('$(_PackageVersionPropsFilePath)')">
    <Compile Remove="**/*.cs;!TestPackageNotBuilt.cs;!obj/**/*.cs;!bin/**/*.cs" />
  </ItemGroup>

  <ItemGroup Condition="Exists('$(_PackageVersionPropsFilePath)')">
    <Compile Remove="TestPackageNotBuilt.cs" />
  </ItemGroup>
  
  <Target Name="SetDefineConstants" BeforeTargets="CoreCompile">
    
     <!-- Get explicit Version from PackageReference metadata -->
    <ItemGroup>
      <!-- filter PackageReference(s) with matching ID -->
      <__J2N_PkgRef Include="@(PackageReference)" Condition="'%(PackageReference.Identity)' == 'J2N'" />
    </ItemGroup>
  
    <PropertyGroup Label="Compilation Options">
      <__J2N_PkgRef_Version>@(_J2N_PkgRef->'%(Version)')</__J2N_PkgRef_Version>

      <_J2N_Version_Raw_Trimmed Condition="'$(__J2N_PkgRef_Version)' != ''">$(__J2N_PkgRef_Version.Trim())</_J2N_Version_Raw_Trimmed>
      <!-- Extract leading numeric version (major[.minor][.patch]) from possibly prerelease string
         e.g. "2.2.0-alpha-0026" -> "2.2.0", "2.1" -> "2.1" -->
      <_J2N_Version_Numeric>$([System.Text.RegularExpressions.Regex]::Match('$(_J2N_Version_Raw_Trimmed)','^\d+(\.\d+){0,2}').Value)</_J2N_Version_Numeric>

      <!-- Default empty -> avoid trying to Parse empty string -->
      <_J2N_Version_Numeric Condition="$(_J2N_Version_Numeric) == ''"></_J2N_Version_Numeric>
    
      <!-- This is defined in SpanTools.ValueStringBuilder.Generator.targets (in the NuGet package) -->
      <DefineConstants Condition=" '$(_J2N_PkgRef_Version_2)' != '' ">FEATURE_J2N</DefineConstants>
      <DefineConstants Condition="$(_J2N_Version_Numeric) != '' And $([System.Version]::Parse('$(_J2N_Version_Numeric)').CompareTo($([System.Version]::new('2.0'))) &gt;= 0)">FEATURE_J2N_2_0_OR_GREATER</DefineConstants>
      <DefineConstants Condition="$(_J2N_Version_Numeric) != '' And $([System.Version]::Parse('$(_J2N_Version_Numeric)').CompareTo($([System.Version]::new('2.1'))) &gt;= 0)">FEATURE_J2N_2_1_OR_GREATER</DefineConstants>
      <DefineConstants Condition="$(_J2N_Version_Numeric) != '' And $([System.Version]::Parse('$(_J2N_Version_Numeric)').CompareTo($([System.Version]::new('2.2'))) &gt;= 0)">FEATURE_J2N_2_2_OR_GREATER</DefineConstants>
    
      <_EffectiveNamespace>$(RootNamespace)</_EffectiveNamespace>
      <_EffectiveNamespace Condition=" '$(ValueStringBuilder_Namespace)' != '' ">$(ValueStringBuilder_Namespace)</_EffectiveNamespace>
      <DefineConstants Condition=" '$(_EffectiveNamespace)' == 'MyNamespace' ">$(DefineConstants);FEATURE_NAMESPACE_MYNAMESPACE</DefineConstants>
      <DefineConstants Condition=" '$(_EffectiveNamespace)' == 'Lucene.Net.Text' ">$(DefineConstants);FEATURE_NAMESPACE_LUCENENETTEXT</DefineConstants>
      <DefineConstants Condition=" '$(_EffectiveNamespace)' == '' Or '$(_EffectiveNamespace.ToLower())' == 'global::' ">$(DefineConstants);FEATURE_NAMESPACE_GLOBAL</DefineConstants>

      <_AllowUnsafe>$(AllowUnsafeBlocks)</_AllowUnsafe>
      <_AllowUnsafe Condition="'$(_AllowUnsafe)' != ''">$(_AllowUnsafe.ToLowerInvariant())</_AllowUnsafe>
      <DefineConstants Condition="'$(_AllowUnsafe)' == 'true'">$(DefineConstants);FEATURE_COMPILE_UNSAFE</DefineConstants>
    
      <DefineConstants Condition=" '$(ValueStringBuilder_IncludeAsMemoryMethods.ToLower())' == 'true' ">$(DefineConstants);FEATURE_VALUESTRINGBUILDER_INCLUDEASMEMORYMETHODS</DefineConstants>
      <DefineConstants Condition=" '$(ValueStringBuilder_IncludeMaxLengthTracking.ToLower())' == 'true' ">$(DefineConstants);FEATURE_VALUESTRINGBUILDER_INCLUDEMAXLENGTHTRACKING</DefineConstants>
      <DefineConstants Condition=" '$(ValueStringBuilder_UseJavaStyleFormatting.ToLower())' == 'true' ">$(DefineConstants);FEATURE_VALUESTRINGBUILDER_USEJAVASTYLEFORMATTING</DefineConstants>
    </PropertyGroup>
    
  </Target>

  <Target Name="EnsureNuGetPackageBuilt" BeforeTargets="PrepareForBuild" Condition="'$(DesignTimeBuild)' != 'true' And '$(SkipPackageBuild.ToLower())' != 'true' ">

    <Message Importance="high" Text="Running NuGet Package Build..." />

    <!-- Build the project that produces the NuGet package -->
    <MSBuild Projects="..\..\src\SpanTools.ValueStringBuilder.Generator.Package\SpanTools.ValueStringBuilder.Generator.Package.csproj" Targets="Restore;PrepareForBuild;Build" Properties="Configuration=$(Configuration)" />

    <!-- Since we may be continually using the last build number (unless a commit occurred),
          we need to clear the project local NuGet cache. -->
    <ForceDeleteDirectory DirectoryPath="$(_RestorePackagesPath)" />

    <!-- Mark restore data as stale so MSBuild will re-run restore -->
    <Delete Files="$(BaseIntermediateOutputPath)project.assets.json" ContinueOnError="true" />

    <!-- Restore again, now that the .nupkg should exist -->
    <MSBuild Projects="$(MSBuildProjectFullPath)" Targets="Restore" Properties="Configuration=$(Configuration)" />
  </Target>

  <Target Name="CleanRestorePackagesPath" AfterTargets="Clean" Condition="'$(DesignTimeBuild)' != 'true' And '$(SkipPackageBuild.ToLower())' != 'true' ">
    <ForceDeleteDirectory DirectoryPath="$(_RestorePackagesPath)" />
  </Target>

  <UsingTask TaskName="ForceDeleteDirectory" TaskFactory="RoslynCodeTaskFactory" AssemblyFile="$(MSBuildToolsPath)\Microsoft.Build.Tasks.Core.dll">
    <ParameterGroup>
      <DirectoryPath ParameterType="System.String" Required="true" />
    </ParameterGroup>
    <Task>
      <Using Namespace="System" />
      <Using Namespace="System.IO" />
      <Code Type="Fragment" Language="cs">
        <![CDATA[
        try
        {
            if (Directory.Exists(DirectoryPath))
            {
                Directory.Delete(DirectoryPath, recursive: true);
            }
        }
        catch (Exception ex)
        {
            // Swallow all exceptions unless MSBuild wants you to fail
            Log.LogMessage(MessageImportance.Low, $"Failed to delete directory '{DirectoryPath}': {ex.Message}");
        }
      ]]>
      </Code>
    </Task>
  </UsingTask>

</Project>
